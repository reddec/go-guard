// Code generated by ./jsonstorage.sh TokenStorage Token Value token_storage.go DO NOT EDIT.
package guard

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

type TokenStorage interface {
	// Get Token by value. Must return ErrTokenNotFound if entity not found.
	Get(ctx context.Context, value string) (*Token, error)
	// Set Token indexed by value.
	Set(ctx context.Context, value *Token) error
	// List Token.
	List(ctx context.Context) ([]Token, error)
	// Delete Token by value.
	Delete(ctx context.Context, value string) error
}

var ErrTokenNotFound = errors.New("not found")

type MemoryTokenStorage struct {
	storage sync.Map
}

func (mts *MemoryTokenStorage) Get(_ context.Context, value string) (*Token, error) {
	v, ok := mts.storage.Load(value)
	if !ok {
		return nil, ErrTokenNotFound
	}
	return v.(*Token), nil
}

func (mts *MemoryTokenStorage) Set(_ context.Context, value *Token) error {
	mts.storage.Store(value.Value, value)
	return nil
}

func (mts *MemoryTokenStorage) List(_ context.Context) ([]Token, error) {
	var list []Token
	mts.storage.Range(func(key, value interface{}) bool {
		t := value.(*Token)
		list = append(list, *t)
		return true
	})
	return list, nil
}

func (mts *MemoryTokenStorage) Delete(_ context.Context, value string) error {
	mts.storage.Delete(value)
	return nil
}

var ErrTokenInvalid = errors.New("value malformed")

const TokenStorageFileSuffix = ".json"

type FileTokenStorage struct {
	Directory string
	pattern   *regexp.Regexp
	init      sync.Once
}

func (fts *FileTokenStorage) Get(_ context.Context, value string) (*Token, error) {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return nil, ErrTokenInvalid
	}

	u, err := fts.readToken(value)
	if errors.Is(err, os.ErrNotExist) {
		return nil, ErrTokenNotFound
	}
	return u, err
}

func (fts *FileTokenStorage) Set(_ context.Context, value *Token) error {
	fts.doInit()
	if !fts.pattern.MatchString(value.Value) {
		return ErrTokenInvalid
	}

	if err := os.MkdirAll(fts.Directory, 0700); err != nil {
		return fmt.Errorf("create dir: %w", err)
	}

	tmpFile, err := os.CreateTemp(fts.Directory, value.Value+"-*.tmp")
	if err != nil {
		return fmt.Errorf("create temp file: %w", err)
	}
	defer tmpFile.Close()

	enc := json.NewEncoder(tmpFile)
	enc.SetIndent("", "  ")
	if err := enc.Encode(value); err != nil {
		_ = tmpFile.Close()
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("encode value: %w", err)
	}

	if err := tmpFile.Close(); err != nil {
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("close temp file: %w", err)
	}

	if err := os.Rename(tmpFile.Name(), filepath.Join(fts.Directory, value.Value)+TokenStorageFileSuffix); err != nil {
		return fmt.Errorf("rename temp file: %w", err)
	}

	return nil
}

func (fts *FileTokenStorage) List(_ context.Context) ([]Token, error) {
	fts.doInit()
	list, err := ioutil.ReadDir(fts.Directory)
	if err != nil {
		return nil, fmt.Errorf("read dir: %w", err)
	}
	var values []Token
	for _, item := range list {
		if item.IsDir() {
			continue
		}
		name := item.Name()
		if !strings.HasSuffix(name, TokenStorageFileSuffix) {
			continue
		}
		v, err := fts.readToken(name[:len(name)-len(TokenStorageFileSuffix)])
		if err != nil {
			return nil, fmt.Errorf("read value %s: %w", name, err)
		}
		values = append(values, *v)
	}
	return values, nil
}

func (fts *FileTokenStorage) Delete(_ context.Context, value string) error {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return ErrTokenInvalid
	}
	return os.Remove(filepath.Join(fts.Directory, value+TokenStorageFileSuffix))
}

func (fts *FileTokenStorage) doInit() {
	fts.init.Do(func() {
		fts.pattern = regexp.MustCompile(`^[a-zA-Z0-9-_.]+$`)
	})
}

func (fts *FileTokenStorage) readToken(value string) (*Token, error) {
	f, err := os.Open(filepath.Join(fts.Directory, value) + TokenStorageFileSuffix)
	if err != nil {
		return nil, fmt.Errorf("open value file: %w", err)
	}
	defer f.Close()

	var out Token
	if err := json.NewDecoder(f).Decode(&out); err != nil {
		return nil, fmt.Errorf("decode value: %w", err)
	}

	return &out, nil
}
