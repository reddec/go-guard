// Code generated by ./jsonstorage.sh UserStorage User Name user_storage.go DO NOT EDIT.
package guard

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

type UserStorage interface {
	// Get User by name. Must return ErrUserNotFound if entity not found.
	Get(ctx context.Context, name string) (*User, error)
	// Set User indexed by name.
	Set(ctx context.Context, value *User) error
	// List User.
	List(ctx context.Context) ([]User, error)
	// Delete User by name.
	Delete(ctx context.Context, name string) error
}

var ErrUserNotFound = errors.New("not found")

type MemoryUserStorage struct {
	storage sync.Map
}

func (mts *MemoryUserStorage) Get(_ context.Context, value string) (*User, error) {
	v, ok := mts.storage.Load(value)
	if !ok {
		return nil, ErrUserNotFound
	}
	return v.(*User), nil
}

func (mts *MemoryUserStorage) Set(_ context.Context, value *User) error {
	mts.storage.Store(value.Name, value)
	return nil
}

func (mts *MemoryUserStorage) List(_ context.Context) ([]User, error) {
	var list []User
	mts.storage.Range(func(key, value interface{}) bool {
		t := value.(*User)
		list = append(list, *t)
		return true
	})
	return list, nil
}

func (mts *MemoryUserStorage) Delete(_ context.Context, value string) error {
	mts.storage.Delete(value)
	return nil
}

var ErrUserInvalid = errors.New("value malformed")

const UserStorageFileSuffix = ".json"

type FileUserStorage struct {
	Directory string
	pattern   *regexp.Regexp
	init      sync.Once
}

func (fts *FileUserStorage) Get(_ context.Context, value string) (*User, error) {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return nil, ErrUserInvalid
	}

	u, err := fts.readUser(value)
	if errors.Is(err, os.ErrNotExist) {
		return nil, ErrUserNotFound
	}
	return u, err
}

func (fts *FileUserStorage) Set(_ context.Context, value *User) error {
	fts.doInit()
	if !fts.pattern.MatchString(value.Name) {
		return ErrUserInvalid
	}

	if err := os.MkdirAll(fts.Directory, 0700); err != nil {
		return fmt.Errorf("create dir: %w", err)
	}

	tmpFile, err := os.CreateTemp(fts.Directory, value.Name+"-*.tmp")
	if err != nil {
		return fmt.Errorf("create temp file: %w", err)
	}
	defer tmpFile.Close()

	enc := json.NewEncoder(tmpFile)
	enc.SetIndent("", "  ")
	if err := enc.Encode(value); err != nil {
		_ = tmpFile.Close()
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("encode value: %w", err)
	}

	if err := tmpFile.Close(); err != nil {
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("close temp file: %w", err)
	}

	if err := os.Rename(tmpFile.Name(), filepath.Join(fts.Directory, value.Name)+UserStorageFileSuffix); err != nil {
		return fmt.Errorf("rename temp file: %w", err)
	}

	return nil
}

func (fts *FileUserStorage) List(_ context.Context) ([]User, error) {
	fts.doInit()
	list, err := ioutil.ReadDir(fts.Directory)
	if err != nil {
		return nil, fmt.Errorf("read dir: %w", err)
	}
	var values []User
	for _, item := range list {
		if item.IsDir() {
			continue
		}
		name := item.Name()
		if !strings.HasSuffix(name, UserStorageFileSuffix) {
			continue
		}
		v, err := fts.readUser(name[:len(name)-len(UserStorageFileSuffix)])
		if err != nil {
			return nil, fmt.Errorf("read value %s: %w", name, err)
		}
		values = append(values, *v)
	}
	return values, nil
}

func (fts *FileUserStorage) Delete(_ context.Context, value string) error {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return ErrUserInvalid
	}
	return os.Remove(filepath.Join(fts.Directory, value+UserStorageFileSuffix))
}

func (fts *FileUserStorage) doInit() {
	fts.init.Do(func() {
		fts.pattern = regexp.MustCompile(`^[a-zA-Z0-9-_.]+$`)
	})
}

func (fts *FileUserStorage) readUser(value string) (*User, error) {
	f, err := os.Open(filepath.Join(fts.Directory, value) + UserStorageFileSuffix)
	if err != nil {
		return nil, fmt.Errorf("open value file: %w", err)
	}
	defer f.Close()

	var out User
	if err := json.NewDecoder(f).Decode(&out); err != nil {
		return nil, fmt.Errorf("decode value: %w", err)
	}

	return &out, nil
}
