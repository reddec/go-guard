#!/bin/bash


function usage {
    echo "$0 <storageName> <typename> <indexField> <file>"
}

STORAGE="$1"
TYPE="$2"
INDEXF="$3"
FILE="$4"

if [ "1$STORAGE" == "1" ]; then
  usage
  exit 1
fi

if [ "1$TYPE" == "1" ]; then
  usage
  exit 1
fi

if [ "1$FILE" == "1" ]; then
  usage
  exit 1
fi

if [ "1$INDEXF" == "1" ]; then
  usage
  exit 1
fi

field=$(echo "$INDEXF" | tr "[:upper:]" "[:lower:]")

cat - > "$FILE" <<EOF
// Code generated by $0 $@ DO NOT EDIT.
package guard

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)


type ${TYPE}Storage interface {
  // Get ${TYPE} by ${field}. Must return Err${TYPE}NotFound if entity not found.
	Get(ctx context.Context, ${field} string) (*${TYPE}, error)
	// Set ${TYPE} indexed by ${field}.
	Set(ctx context.Context, value *${TYPE}) error
	// List ${TYPE}.
	List(ctx context.Context) ([]${TYPE}, error)
	// Delete ${TYPE} by ${field}.
	Delete(ctx context.Context, ${field} string) error
}

var Err${TYPE}NotFound = errors.New("not found")

type Memory${STORAGE} struct {
	storage sync.Map
}

func (mts *Memory${STORAGE}) Get(_ context.Context, value string) (*${TYPE}, error) {
	v, ok := mts.storage.Load(value)
	if !ok {
		return nil, Err${TYPE}NotFound
	}
	return v.(*${TYPE}), nil
}

func (mts *Memory${STORAGE}) Set(_ context.Context, value *${TYPE}) error {
	mts.storage.Store(value.${INDEXF}, value)
	return nil
}

func (mts *Memory${STORAGE}) List(_ context.Context) ([]${TYPE}, error) {
	var list []${TYPE}
	mts.storage.Range(func(key, value interface{}) bool {
		t := value.(*${TYPE})
		list = append(list, *t)
		return true
	})
	return list, nil
}

func (mts *Memory${STORAGE}) Delete(_ context.Context, value string) error {
	mts.storage.Delete(value)
	return nil
}

var Err${TYPE}Invalid = errors.New("value malformed")

const ${STORAGE}FileSuffix = ".json"

type File${TYPE}Storage struct {
	Directory string
	pattern   *regexp.Regexp
	init      sync.Once
}

func (fts *File${TYPE}Storage) Get(_ context.Context, value string) (*${TYPE}, error) {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return nil, Err${TYPE}Invalid
	}

	u, err := fts.read${TYPE}(value)
  if errors.Is(err, os.ErrNotExist) {
    return nil, Err${TYPE}NotFound
  }
  return u, err
}

func (fts *File${TYPE}Storage) Set(_ context.Context, value *${TYPE}) error {
	fts.doInit()
	if !fts.pattern.MatchString(value.${INDEXF}) {
		return Err${TYPE}Invalid
	}

	if err := os.MkdirAll(fts.Directory, 0700); err != nil {
    return fmt.Errorf("create dir: %w", err)
  }

	tmpFile, err := os.CreateTemp(fts.Directory, value.${INDEXF} + "-*.tmp")
	if err != nil {
		return fmt.Errorf("create temp file: %w", err)
	}
	defer tmpFile.Close()

	enc := json.NewEncoder(tmpFile)
	enc.SetIndent("", "  ")
	if err := enc.Encode(value); err != nil {
		_ = tmpFile.Close()
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("encode value: %w", err)
	}

	if err := tmpFile.Close(); err != nil {
		_ = os.Remove(tmpFile.Name())
		return fmt.Errorf("close temp file: %w", err)
	}

	if err := os.Rename(tmpFile.Name(), filepath.Join(fts.Directory, value.${INDEXF})+${STORAGE}FileSuffix); err != nil {
		return fmt.Errorf("rename temp file: %w", err)
	}

	return nil
}

func (fts *File${TYPE}Storage) List(_ context.Context) ([]${TYPE}, error) {
	fts.doInit()
	list, err := ioutil.ReadDir(fts.Directory)
	if err != nil {
		return nil, fmt.Errorf("read dir: %w", err)
	}
	var values []${TYPE}
	for _, item := range list {
		if item.IsDir() {
			continue
		}
		name := item.Name()
		if !strings.HasSuffix(name, ${STORAGE}FileSuffix) {
			continue
		}
		v, err := fts.read${TYPE}(name[:len(name)-len(${STORAGE}FileSuffix)])
		if err != nil {
			return nil, fmt.Errorf("read value %s: %w", name, err)
		}
		values = append(values, *v)
	}
	return values, nil
}

func (fts *File${TYPE}Storage) Delete(_ context.Context, value string) error {
	fts.doInit()
	if !fts.pattern.MatchString(value) {
		return Err${TYPE}Invalid
	}
	return os.Remove(filepath.Join(fts.Directory, value+${STORAGE}FileSuffix))
}

func (fts *File${TYPE}Storage) doInit() {
	fts.init.Do(func() {
		fts.pattern = regexp.MustCompile(\`^[a-zA-Z0-9-_.]+$\`)
	})
}

func (fts *File${TYPE}Storage) read${TYPE}(value string) (*${TYPE}, error) {
	f, err := os.Open(filepath.Join(fts.Directory, value) + ${STORAGE}FileSuffix)
	if err != nil {
		return nil, fmt.Errorf("open value file: %w", err)
	}
	defer f.Close()

	var out ${TYPE}
	if err := json.NewDecoder(f).Decode(&out); err != nil {
		return nil, fmt.Errorf("decode value: %w", err)
	}

	return &out, nil
}


EOF

goimports -w "$FILE"